```
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
---------+---------+---------+---------+---------X---------+---------+---------+---------+---------X
$Lastupdate: 2021/11/12 11:10:09 $ T.AIHANA
```

* [A half-hour to lean Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)

# 30分で学ぶ Rust

## はじめに

プログラミング言語の「流暢さ」を向上させるためには、その言語のプログラムをたくさん読む必要があります。
でも何も知らないのに、どうすればたくさん読むことができるのでしょうか？

この記事では、Rust の概要をかいつまんでいくのではなく、できるだけたくさんの Rust の「スニペット」を調べて、それらに含まれるキーワードや記号の意味を解説していきます。

準備はいいですか？
では始めましょう！

----

## ``let`` キーワード


``let`` は変数名を一つ宣言します:

```Rust
let x;    // "x" という変数名を宣言する
x = 42;    // 数値の 42 を "x" という変数に割り当てる
```

これは一行で書くこともできます：

```Rust

let x = 42;
```

記号 ``:``（コロン）を使って変数の型を明示的に指定できます（この記号は「型の注釈（*annotation*）」を表します）：

```Rust
let x: i32;    // `i32` は符号付き 32-bit 整数型である
x = 42;

// 注釈できる型は i8, i16, i32, i64, i128 があります
// 他に符号なしだと u8, u16, u32, u64, u128 があります
```

これも一行で書くことができます：

```Rust
let x: i32 = 42;
```

変数名を宣言したあとでその変数を初期化すると、コンパイラは初期化が完了するまで変数を利用できないようにします。

```Rust
let x;
foobar(x);    // error: borrow of possibly-uninitialized variable: `x`
x = 42;
```

ただし、次の書き方は全く問題ありません：

```Rust
let x;
x = 42;
foobar(x);    // ここから変数 `x` の型がコンパイラによって推測される
```

記号 ``_``（アンダースコア）は特別な変数名です。
と言うよりは「名前無し」の変数です。もともとは何かを「捨てる」という意味があります：

```Rust
// これは「何もしません」（なぜなら `42` は定数だからです）
let _ = 42;

// これは `get_thing()` を呼び出しますが、返り値は破棄されます
let _ = get_thing()
```

``_`` で始まる名前は通常の変数名で、単にコンパイラがそれらが使用されていないことを警告しないだけです：

```Rust
// 最終的にどこかで変数 `_x` を使うかもしれないが、このプログラムは「まだ開発中」のものなので
// 今のところはコンパイラには警告を無視してもらう（という意図がある）
let _x = 42;
```

同じ名前を別個に宣言することもできます。
すなわち変数の宣言を不可視（*shadow*）にできます：

```Rust
let x = 13;
let x = x + 3;    // 上の行のあとで `x` を使うと二番目の` x` だけが参照される
                  // （すなわち最初の `x` はもう存在しない）
```

Rust にはタプル（*Tuple*）があります。
タプルは「さまざまな型の値を要素とする固定長のコレクション型」です。

```Rust
let pair = ('a', 17);
pair.0;    // これは 'a'
pair.1;    // これは 17
```

変数 `pair` の型にきちんと注釈を付けたいのであれば、次のように書きます：

```Rust
let pair: (char, i32) = ('a', 17);
```

タプルは値を割り当てると「分解（*destructured*）」される可能性があります。
すなわちタプルという集合体が個々の要素に分割されるということです：

```Rust
let (some_char, some_int) = ('a', 17);
// ここで `some_char` は `a`、`some_int` は 17 になる
```

この仕様は、特に関数からタプルを返す際に便利です：

```Rust
let (left, right) = slice.split_at(middle);
```

もちろんタプルを分解する際に記号 `_` を使って一部の要素を破棄することもできます：

```Rust
let (_, right) = slice.split_at(middle);
```

記号 `;`（セミコロン）は文の終端を意味します：

```Rust
let x = 3;
let y = 5;
let z = y + x;
```

また、文は複数行にまたがって書くことも可能です：

```Rust
let x = vec![1, 2, 3, 4, 5, 6, 7, 8]
    .iter()
    .map(|x| x + 3)
    .fold(0, |x, y| x + y)
```

（これらが実際に何を意味しているかについては、後ほど説明します）

-----

## `fn` キーワード

`fn` は関数を一つ宣言します。
次は void 関数の宣言です：

```Rust
fn greet() {
    println!("Hi there!");
}
```

そして、次は一個の 32-bit 符号付き整数値を返す関数の宣言です。
記号 `->` は関数の返り値の型を示しています：

```Rust
fn fiar_dice_roll() -> i32 {
    4
}
```

中カッコのペア `{` と `}` はブロックを宣言するもので、ブロックはそれ専用の「スコープ」を持ちます：

```Rust
// この例は "in" を出力してから "out" を出力します
fn main() {
    let x = "out"
    {
        // これは別の `x` です
        let x = "in";
        println!("{}", x);
    }
    println!("{}", x);
}
```

ブロックも「式」です。
これは値を評価すると言う意味です。

```Rust
// これは:
let x = 42;

// 次と同じです：
let x = { 42 };

```

ブロックの中に複数の文を書くこともできます：

```Rust
let x = {
    let y = 1;    // 最初の文
    let z = 2;    // 二番目の文
    y + z    // これが *最後* の文 ー ブロック全体で評価するもの
};
```

そして「関数の最後で記号 `;` を省略する」ことは関数から返ると同じ意味になります。
すなわち、次の二つの関数は同じです：

```Rust
fn fair_dice_roll() -> i32 {
    return 4;
};

fn fair_dice_roll() -> i32 {
    4
};
```

条件文のキーワード `if` もまた式です：

```Rust
fn fair_dice_roll() -> i32 {
    if feeling_lucky {
        6
    } else {
        4
    }
}
```

キーワード `match` も式です：

```Rust
fn fair_dice_roll() -> i32 {
    match feeling_lucky {
        true => 6,
        false => 4,
    }
}
```

記号 `.`（ドット）は通常は一個の値が持ついくつかのメンバ（*field*）にアクセスする際に使用します：

```Rust
let a = (10, 20);
a.0;    // これは `10` です

let amos = get_some_struct();
amos.nickname;    // これは "fasterthanlime" です
```

または値に対してメソッドを呼び出す際に使います：

```Rust
let nick = "fasterthanlime";
nick.len();    // これは 14 です
```

記号 `::`（ダブルコロン）も似ていますが、これは名前空間（*namespace*）を操作するものです。
次の例で、`std` は *crate* （と言うライブラリ）、`cmp` はモジュール名（ソースファイル）、そして `min` が関数名とすると：

```Rust
let least = std::cmp::min(3, 8);    // これは 3
```

命令 `use` は他の名前空間からいくつかの名前を「スコープの中に取り込む（インポートする）」際に使用します：

```Rust
use std::cmd::min;

let least = min(7, 1);    // これは 1 です
```

命令 `use` の内側では中カッコ `{` と `}` には別の意味になります：
これらは「塊（*globs*）」です。
ここで、もし関数 `min` と `max` の両方をスコープの中にインポートしたい場合、次のいずれかで実現できます：

```Rust
// これは動作します：
use std::cmp::min;
use std::cmp::max;

// これも動作します：
use std::cmp::{min, max};

// これも動作するんです！
use std::{cmp::min, cmp::max};
```

記号 ``*``（ワイルドカード）は名前空間からすべてのシンボルをインポートしてくれます：

```Rust
// これはスコープ内にある `min` と `max` を取り込み、さらに他のシンボルもたくさんとりこみます
use std::cmap::*;
```

「型」も名前空間です。
そしてメソッドを通常の関数のように呼び出すことができます：

```Rust
let x = "amos".len();    // これは 4 です
let x = str::len("amos");    // これも 4 です
```

この ``str`` 型は基本型の一つですが、デフォルトのスコープの中にはもっとたくさんの基本型ではない型もあります。

```Rust
// `Vec` 型は通常の構造体であって、基本型ではありません
let v = Vec::new();

// これは上と同じことをするコードですが、`Vec` に名前空間の「完全なパス」がついたものになっています
let v = std::vec::Vec::new();
```

Rust がすべてのモジュールの先頭で名前空間の完全なパスを補完するので、前者のコードのような書き方でも動作するというわけです：

```Rust
use std::prelude::v1::*;
```

（この仕組みにより、`Vec` や `String`、`Option`、そして `Result` といったたくさんのシンボルが再エクスポートされます）。


構造体の場合は `struct` キーワードを付けて宣言します：

```Rust
struct Vec2 {
    x: f64,    // 64-bit の浮動小数点型（いわゆる倍精度）
    y: f64,
}
```

これらは *struct literals* を使って初期化することができます：

```Rust
let v1 = Vec2 {x: 1.0, y: 3.0};
let v2 = Vec2 {y: 2.0, x: 4.0};
// メンバを書く順番は関係ありません（名前だけ合わせて下さい）
```

別の構造体で、残りのメンバを初期化させる「ショートカット」があります：

```Rust
let v3 = Vec2 {
    x: 14.0,
    ..v2
};
```
    
----

## Funky

普段から端末を使い、[端末を IDE の類として利用](https://blog.sanctum.geek.nz/unix-as-ide-files/)したいと考えているのであれば、現在のディレクトリを起点にして別の端末に変更していけると便利です。
これを実現する方法はいろいろあります。
[DirEnv](https://blog.sanctum.geek.nz/unix-as-ide-files/) というツールは任意のディレクトリへ移動したら `.env` なるファイルを読み込んで環境変数を適用したり無効にしたりします。
[SmartCd](https://blog.sanctum.geek.nz/unix-as-ide-files/) も同様の類のツールで、特定のディレクトリへ移動するたびに任意の Shell スクリプトを実行してくれます。
すなわち、いろいろなサービスを起動したり停止したりコマンド・プロンプトを変更したり、他にも必要なことは何でもできるというわけです。

ただし、この類のツールの中で私のお気に入りは名前が面白い [Funky](https://github.com/bbugyi200/funky#funky-) というツールです。
これは「Shell の関数を簡単に定義できて、柔軟性が高く、より対話志向にすることで Shell 関数そのものを一つ上のレベルに引き上げる」ことができます。

`Funky` の仕組みは単純です：
任意のディレクトリへ移動すると、`funky` は `.funky` ファイルを探します。
このファイルにはいろいろな bash の関数の一覧が記載されています。
それらの関数の定義を有効にし、逆に他のディレクトリへ移動する際は有効にしていた関数の定義を無効にします。

これは、例えば私が [Jekyll](http://jekyllrb-ja.github.io/) を使ってブログを書く専用のディレクトリにいる時は、新しい投稿を作成したり、Markdown の文法をチェックしたり、いろいろな画像をダウンロードするなどの（エイリアスされた独自の）コマンドを使えるということです。
`funky` と入力すると（エイリアスされた独自の）コマンドの一覧が表示されます：


```shell
$ funky
lint() { markdownlint --fix "./_posts/*.md"; }
set-header() { cp "$(latest-image)" "$(image-folder)/header.jpg"; }
set-image() { cp "$(latest-image)" "$(image-folder)/$(date +%s).png"; }
```

`funky` はこれ以外のこともいろいろできます。
関数を対話式に追加したり編集するとか、（特定のディレクトリに依存しない）グローバルな関数やコマンドのエイリアスを登録するといった機能があります。
この中で私が気に入っているのは特定のコンテキストで短いエイリアスを任意のコマンドに素早く変換することができる機能です。

### Funky のインストールについて

`pip` を使って `Funky` をインストールできます：

```shell
$ pip3 install funky
```

そのあとに、お使いの `.zshrc` や `.bashrc` あるいは同等の設定ファイルにフックを追加します：

```shell
## pip が funky.sh をインストールした場所を見つけて、それを source します
source /usr/local/lib/python3.9/site-packages/scripts/shell/funky.sh
```

----

## Fuzzy Finder (FZF)

### FIXME（画像）
「この投稿のために作成した画像ファイルの場所を `fzf` を使って特定した例」


ここまで紹介してきた `broot` と `funky` を使って私の生産性が向上していたとしたら、さらにたくさんのツールを使っても「生産性しか」向上させることができません。

そこで [Lobste.rs](https://lobste.rs/s/yfgwjr/what_interesting_command_line_tools_do) なる掲示板サイトへ行って、他にどんなツールを使っているのか質問してみました。

`FZF` なるキーワードをかなりたくさん見かけたので、そのツールを今から使ってみることにします。


[FZF](https://github.com/junegunn/fzf) とはコマンドラインの「あいまい」検索ツールです。

このツールは、コマンドラインで何か文字を入力する必要があるところで文字に似たキーワード（*fuzzy keyword*）に一致するオプションを対話式にそして高速にフィルタリングすることができます。

付属のショートカット（`/usr/local/opt/fzf/install`）をいろいろインストールしておくと、いろいろな場所で `**` キーワードと対話式のあいまい検索（インクリメンタル検索）を使って目的のパス名に絞り込んでいくことができます。

さらに `FZF` は `history` コマンドの結果を検索するのも高速です。

入力したキーワードを読み込んで対話式に絞り込んだ候補の一覧を表示し、そこから選択した文字を反対側の欄に送るといった UNIX スタイルのフィルタですが、そのように一言で紹介してしまうと、その有用性が過小評価されてしまいます。

私は、Alexey Samoshkin 氏による心地ちよいピアノを BGM として `FZF` のさまざまな使い方について説明している下記の動画をご覧になることをおすすめします。

### FIXME（動画）

### FZF のインストールについて

お使いの[パッケージ・マネージャに応じた方法で](https://github.com/junegunn/fzf#using-linux-package-managers)`FZF` をインストールして下さい：

```shell
$ brew install fzf
```

そのあとに、お使いの `.zshrc` や `.bashrc` あるいは同等の設定ファイルにフックを追加します：


```shell
## ZSH の場合
$ source ~/.fzf.zsh

## BASH の場合
$ source ~/.fzf.bash
```

----

## McFly

### FIXME（画像）
「`McFly` を使って、このパスにある "[earthly](https://earthly.dev)" というコマンドのオプションをいろいろ提示している例」

`FZF` は（`vim **` などで）ファイルをオープンする際にコマンドラインから対象となるファイル名をフィルタリングするのに最適なツールですが、コマンドラインを補完するような場合は、`.history` ファイルに記録された実際のコマンドライン列よりももっとたくさんの「オプション情報」が含まれます。
[McFly](https://github.com/cantino/mcfly/) は、これらの情報を使ってもっと関連性の高い結果を提供しようとするツールです。

でも「オプション情報」って何んでしょうか？
まず `McFly` は、次のようなヒューリスティック分析した結果に重み付けして提案するオプションを検討します：

- そのコマンドの前に入力したコマンド
- そのコマンドを実行した回数
- 最後にそのコマンドを実行した時期

これらのすべてを SQLite のデータベースを利用して追跡し、次のような条件で重み付けして提示します：

- コマンドの終了ステータス
- コマンドを実行したディレクトリ
- 以前 `McFly` で選択したことがあるかどうか

私にとって、実行に失敗したコマンドが提示されるのはちょっと不満ですが、現在いるディレクトリに応じて提示してくれる選択肢を絞り込んだり、今まで一度も使ったことがないオプションの重み（ランク）が低くなるなんてことは意外でした。

`McFly` はニューラル・ネットを使って重み付けしていきますが、ここで考えられる欠点の一つは、SQLite のデータベースが肥大化した場合に選択肢が提示されるまでに時間がかかるということです。
ただし `MCFLY_HISTORY_LIMIT` という環境変数でデータベースの肥大化を制限することができます。

使いだしてからまだ数日しか経っていないので公正な評価を下すことはできませんが、実際の使用に合わせてツールをいろいろカスタマイズするためのオプションを利用するというコンセプトは、私にかなり希望を与えてくれるものではあります。


### McFly のインストールについて

[いろいろな方法](https://github.com/cantino/mcfly/#installation)で `McFly` をインストールすることができます。
次は `brew` を使う例です：

```shell
$ brew tap cantino/mcfly
$ brew install mcfly
```

そのあとに、お使いの .zshrc や .bashrc あるいは同等の設定ファイルにフックを追加します：

```shell
$ eval "$(mcfly init zsh)"
```

私にとって、ELF が init スクリプトをホームディレクトリにダンプするのではなく、init スクリプトを出力してくれるのはいい感じです。
（次に紹介する）`zoxide` も同じようにしてくれます。


あとで `FZF` が `McFly` の `CTRL-R` キーと干渉していることがわかり、`McFly` を動かすために `FZF` の init スクリプトにある定義をコメントアウトしてやる必要がありました。

----

## Better CD


### FIXME（画像）
「`cd` の代替コマンドとして `zoxide` を使った例」

いろいろなパスを補完する際は `FZF` は便利なのですが、`cd` コマンドを使ってディレクトリを移動するときは役に立ちませんでした：
ホーム・ディレクトリから `cd ** [TAB]` と入力すると `FZF` が全候補のリストを作成するまでしばらく待たされます。
任意のディレクトリへ移動する際は、ZSH の補完機能で `cd [TAB] ディレクトリの選択 [TAB] ディレクトリの選択` とした方がはるかに高速でした。

とはいえ `cd` コマンドを改善しようとするツールがたくさん存在しています。
[autojump](https://github.com/wting/autojump) とか [z](https://github.com/rupa/z)、あるいは [Fasd](https://github.com/clvv/fasd) はすべてディレクトリの利用状況を追跡し、いつもアクセスしているディレクトリへ移動するショートカットのキーを提供くれます。
[r/commandline](https://www.reddit.com/r/commandline/comments/4v5nlt/what_cd_tool_do_you_use_if_any_autojump_j_z_etc/) には `cd` コマンドを置き換えるこれらのツールの詳細な説明が紹介されていますが、その中で最も「勢いのある」ツールが `zoxide` でした。
[zoxide](https://github.com/ajeetdsouza/zoxide) は `z` ツールを Rust で書き直したもので高速化がウリです。

インストールしたあと、今までの `cd`（あるいは `z ~/path/foo/bar`）コマンドのように利用できますが、さらに（重み付けされた）パス名に一致するかしないか（`z bar ~= cd ~/path/foo/bar` の結果）に基づいて移動先のディレクトリを選択することも可能です。
移動するディレクトリのフルパス名を指定する代わりに、パス名に含まれる（重複しない）文字列の一部を指定できるので、`zoxide` はその文字列の利用履歴を使って目的のディレクトリへ移動してくれます。

置き換えを容易にするために、`cd` コマンドを `zoxide` ツールで置き換えることを選択しました。
これは Shell を初期化するコードを追加する（`eval "$(zoxide init zsh --cmd cd)"`）ときに `--cmd` オプションを渡すと同じくらい簡単でした。

### zoxide のインストールについて

[いろいろな方法](https://github.com/ajeetdsouza/zoxide#step-1-install-zoxide)で `zoxide` をインストールすることができます。

```shell
$ brew install zoxide
```

そのあとに、お使いの .zshrc や .bashrc あるいは同等の設定ファイルにフックを追加します：

```shell
eval "$(zoxide init zsh --cmd cd)"
```

----

## GitUpdate

これも [Lobste.rs](https://lobste.rs/s/yfgwjr/what_interesting_command_line_tools_do) なる掲示板サイトのスレッドで見つけたツールです。
私は git のブランチで作業しているときには頻繁に commit していくほうです。
例えばブログの投稿で非常に大きな文の段落を削除する前とか、コードの一部をリファクタリングしようとする前には、まずそこまでの作業結果を commit しておきます。
もちろん、それらの commit はあとで squash または再構築することになりますが、面倒なので次に示す `wip`（*Working In Progress*（作業中の意味））なる git エイリアスを定義しておいて commit に手間がかからないようにしています。

```shell
git wip = !git add --all; git ci -m WIP
```

[gitupdate](https://github.com/nikitavoloboev/gitupdate) は、このようなアイディアを簡単に改善してくれます。
`gitupdate .` と入力するとファイルを commit しますが、その際に変更されたファイル名（ただし拡張子は除く）を使って、より意味のある commit メッセージを作成してくれます。
これは、commit メッセージが重要ではない場面で最適です。


### FIXME（画像）
「`GitUpdate` が commit メッセージを作成し、commit して push までしてくれる例」

### GitUpdat のインストールについて

```shell
$ git clone https://github.com/nikitavoloboev/gitupdate
$ go build
$ sudo cp gitupdate /usr/local/bin
```

----

## その他のツール

他にも便利なコマンドライン・ツールがたくさんあります。
この記事ですべてを紹介することができないくらいたくさんあります。
例えば、私は [./jq](https://stedolan.github.io/jq/) 、[mitmproxy](https://earthly.dev/blog/mitmproxy)、[Pandoc](https://pandoc.org/)、そして [PSTree](https://man7.org/linux/man-pages/man1/pstree.1.html) といったツールをよく使っています。
さらに、一般的な POSIX 系ツールを Rust ですべて書き換えてしまうものもあります。

もちろん [Earthly](https://earthly.dev/)自身もコマンドライン・ツールの一種であり、 いろいろな開発ステップをまとめるためにいつも使っています。
文章の妥当性をチェックするために使用しているツールは、もはや私の仕事の標準的な部分になっています。

貴方はどんな特別な（あまり一般的ではない）コマンドライン・ツールをお使いですか？
もしそんなツールをお使いなら、ぜひ教えて下さい。
私の Twitter アカウントと E-メールアドレスを下に記載しておきます。
貴方がどんなツールを使っているのか聞いてみたいです。


### Adam Gordon Bell 氏

Earthly についての情報を広めている。
CoRecursive のポッドキャストのホストを務める。
カニンガムの法則の物理的具現者。

[Twitter](https://twitter.com/adamgordonbell)
[E-メール](mailto:adam+website@earthly.dev)
[ホームページ](https://corecursive.com/)
